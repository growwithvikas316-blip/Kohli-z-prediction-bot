import telebot
import threading
import time
import random
import pytz
from datetime import datetime, timedelta
from telebot import types
import json
import os

# ===============================
# ðŸ”§ MAIN CONFIGURATION
# ===============================
HOST_BOT_TOKEN = "8372270378:AAEXNRXUD2xTwShxB7z7WR5uqX2NrWBvN6o"
ADMIN_ID = 7741897793

bot = telebot.TeleBot(HOST_BOT_TOKEN, parse_mode="Markdown")

# ===============================
# ðŸŒ GLOBAL STORAGE
# ===============================
awaiting_token_from = set()
hosted_bots = {}

# ===============================
# ðŸ”® PREDICTION ENGINE
# ===============================
def generate_prediction():
    num = random.randint(0, 9)
    if num >= 5:
        big_small = "ðŸ”´ BIG"
        image = "https://i.postimg.cc/VL8z327L/IMG-20250908-115951-469.jpg"
    else:
        big_small = "ðŸ”µ SMALL"
        image = "https://i.postimg.cc/FzthF6Np/IMG-20250908-115954-296.jpg"
    return big_small, num, image


def get_period_number():
    ist = pytz.timezone("Asia/Kolkata")
    now = datetime.now(ist)
    yyyyMMdd = now.strftime("%Y%m%d")
    total_minutes = now.hour * 60 + now.minute
    return f"{yyyyMMdd}1000{10001 + total_minutes}"


def get_remaining_seconds():
    ist = pytz.timezone("Asia/Kolkata")
    now = datetime.now(ist)
    return 60 - now.second if now.second < 60 else 0


def send_prediction(bot_obj, chat_id, period, big_small, num, image):
    caption = f"""
ðŸŽ¯ *KOHLI AI Prediction*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ§¾ *Period:* `{period}`
ðŸ§© *Prediction:* {big_small} â€“ *{num}*
â± *Next:* 1 Minute
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ _Auto-generated by BDG AI Engine_
"""
    try:
        bot_obj.send_photo(chat_id, image, caption=caption)
    except Exception as e:
        print(f"[!] Prediction send failed to {chat_id}: {e}")


# ===============================
# ðŸ“Š USER STATS FUNCTIONS
# ===============================
def load_users(file_path):
    if not os.path.exists(file_path):
        return {}
    with open(file_path, "r") as f:
        try:
            return json.load(f)
        except:
            return {}


def save_users(file_path, data):
    with open(file_path, "w") as f:
        json.dump(data, f, indent=2)


def update_user_stats(user_id, file_path):
    users = load_users(file_path)
    now = datetime.now().strftime("%Y-%m-%d")
    if str(user_id) not in users:
        users[str(user_id)] = {"first_seen": now, "last_seen": now, "usage_count": 1}
    else:
        users[str(user_id)]["last_seen"] = now
        users[str(user_id)]["usage_count"] += 1
    save_users(file_path, users)


def get_stats(file_path):
    users = load_users(file_path)
    today = datetime.now()
    day1, day2 = 0, 0
    top_users = sorted(users.items(), key=lambda x: x[1]["usage_count"], reverse=True)
    for u in users.values():
        last = datetime.strptime(u["last_seen"], "%Y-%m-%d")
        delta = (today - last).days
        if delta == 0:
            day1 += 1
        elif delta == 1:
            day2 += 1
    top_list = "\n".join(
        [f"ðŸ‘¤ `{uid}` â€” {info['usage_count']} uses" for uid, info in top_users[:5]]
    ) or "No users yet."
    return len(users), day1, day2, top_list


# ===============================
# ðŸ§  HOSTED PREDICTION BOT
# ===============================
def start_hosted_prediction_bot(token, owner_id, hosted_id):
    try:
        hosted = telebot.TeleBot(token, parse_mode="Markdown")
        me = hosted.get_me()
    except Exception as e:
        raise RuntimeError(f"âŒ Invalid Token or Bot Inaccessible: {e}")

    active_dict = {}
    user_channels = {}
    user_file = f"users_{me.id}.json"

    def start_prediction_cycle(bot_obj, chat_id, channel_id=None):
        last_period = None
        while active_dict.get(chat_id):
            period = get_period_number()
            if period != last_period:
                big_small, num, image = generate_prediction()
                send_prediction(bot_obj, chat_id, period, big_small, num, image)
                if channel_id:
                    send_prediction(bot_obj, channel_id, period, big_small, num, image)
                last_period = period
            for _ in range(get_remaining_seconds(), 0, -1):
                if not active_dict.get(chat_id):
                    break
                time.sleep(1)

    def create_prediction_menu():
        kb = types.ReplyKeyboardMarkup(resize_keyboard=True)
        kb.row("ðŸ§  Start Prediction", "ðŸ›‘ Stop Prediction")
        kb.row("ðŸ“¢ Set Channel", "ðŸ“Š Stats")
        kb.row("ðŸ‘‘ Developer")
        return kb

    @hosted.message_handler(commands=["start"])
    def start(msg):
        update_user_stats(msg.from_user.id, user_file)
        kb = create_prediction_menu()
        hosted.send_message(
            msg.chat.id,
            f"ðŸ¤– *Welcome to {me.first_name}'s Prediction Bot*\n\n"
            f"ðŸ’¡ Get 1-minute Wingo Predictions + Channel Auto Post.\n"
            f"Use the buttons below ðŸ‘‡",
            reply_markup=kb,
        )

    @hosted.message_handler(func=lambda m: True)
    def buttons(msg):
        text = msg.text
        cid = msg.chat.id
        update_user_stats(cid, user_file)

        if text == "ðŸ§  Start Prediction":
            if active_dict.get(cid):
                hosted.send_message(cid, "âš ï¸ Prediction already running.", reply_markup=create_prediction_menu())
                return
            active_dict[cid] = True
            ch = user_channels.get(cid)
            hosted.send_message(
                cid,
                "âœ… Prediction started.\n"
                f"{'ðŸ“¢ Channel linked: ' + str(ch) if ch else 'No channel linked yet.'}",
                reply_markup=create_prediction_menu(),
            )
            threading.Thread(
                target=start_prediction_cycle,
                args=(hosted, cid, ch),
                daemon=True,
            ).start()

        elif text == "ðŸ›‘ Stop Prediction":
            active_dict[cid] = False
            hosted.send_message(cid, "ðŸ›‘ Prediction stopped.", reply_markup=create_prediction_menu())

        elif text == "ðŸ“¢ Set Channel":
            hosted.send_message(
                cid,
                "ðŸ“¢ Send your *channel username* (like `@yourchannel`) or *channel ID* (like `-100xxxxxxxxxx`).\n\n"
                "âš ï¸ Make sure your bot is *admin* in that channel.",
                parse_mode="Markdown",
            )
            user_channels[cid] = "waiting"

        elif text == "ðŸ“Š Stats":
            total, d1, d2, top = get_stats(user_file)
            hosted.send_message(
                cid,
                f"ðŸ“Š *Bot Usage Statistics*\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"ðŸ‘¥ Total Users: *{total}*\n"
                f"ðŸ“… Active Today: *{d1}*\n"
                f"ðŸ“… Active Yesterday: *{d2}*\n\n"
                f"ðŸ† *Top Users:*\n{top}",
                parse_mode="Markdown",
                reply_markup=create_prediction_menu(),
            )

        elif text == "ðŸ‘‘ Developer":
            markup = types.InlineKeyboardMarkup()
            markup.add(types.InlineKeyboardButton("ðŸ’¬ Message Developer", url="https://t.me/xxLEGEND_KOHLI"))
            hosted.send_message(cid, "ðŸ‘‘ Developer Contact:", reply_markup=markup)

        elif user_channels.get(cid) == "waiting":
            channel_input = text.strip()
            try:
                hosted.send_message(channel_input, "âœ… Channel linked successfully!")
                user_channels[cid] = channel_input
                hosted.send_message(
                    cid,
                    f"âœ… Channel linked: `{channel_input}`\n\nPredictions will now be auto-posted there.",
                    parse_mode="Markdown",
                    reply_markup=create_prediction_menu(),
                )
            except Exception as e:
                hosted.send_message(
                    cid,
                    f"âŒ Failed to link channel. Ensure bot is admin.\nError: {e}",
                    reply_markup=create_prediction_menu(),
                )
                user_channels[cid] = None

    def run_bot():
        try:
            hosted.infinity_polling(timeout=60, long_polling_timeout=60)
        except Exception as e:
            print(f"[!] Hosted bot stopped: {e}")

    thread = threading.Thread(target=run_bot, daemon=True)
    thread.start()

    return {
        "token": token,
        "thread": thread,
        "info": {"username": me.username, "id": me.id},
        "running": True,
    }


# ===============================
# ðŸ’¼ MAIN HOSTING BOT SYSTEM
# ===============================
def hosting_menu():
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True)
    kb.row("âž• Create Hosted Bot", "ðŸ“‹ My Hosted Bots")
    kb.row("ðŸ›  Stop Hosted Bot", "ðŸ  Back to Main")
    return kb


def main_menu():
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True)
    kb.row("ðŸ¤– Hosting Bot", "ðŸ‘‘ Developer")
    return kb


@bot.message_handler(commands=["start"])
def start(msg):
    bot.send_message(
        msg.chat.id,
        "ðŸš€ *Welcome to KOHLI X Hosting Bot*\n\n"
        "Host your own Prediction Bot here.\nPress *Hosting Bot* to begin.",
        reply_markup=main_menu(),
    )


@bot.message_handler(func=lambda m: True)
def handle_buttons(msg):
    uid = msg.chat.id
    text = msg.text.strip()

    if text == "ðŸ‘‘ Developer":
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("ðŸ’¬ Message Developer", url="https://t.me/xxLEGEND_KOHLI"))
        bot.send_message(uid, "ðŸ‘‘ Developer Contact:", reply_markup=markup)
        return

    if text == "ðŸ¤– Hosting Bot":
        bot.send_message(uid, "ðŸ“¦ Hosting Control Panel", reply_markup=hosting_menu())
        return

    if text == "ðŸ  Back to Main":
        bot.send_message(uid, "ðŸ  Returned to main menu.", reply_markup=main_menu())
        return

    if text == "âž• Create Hosted Bot":
        awaiting_token_from.add(uid)
        bot.send_message(
            uid,
            "ðŸª„ *Create Hosted Prediction Bot*\n\n"
            "Please send your Bot Token now.\nExample:\n`123456789:AAEx...`\n\n"
            "âš ï¸ Token will be verified and forwarded to Admin.",
            parse_mode="Markdown",
        )
        return

    if uid in awaiting_token_from:
        token = text
        awaiting_token_from.discard(uid)
        if ":" not in token or len(token) < 30:
            bot.send_message(uid, "âŒ Invalid Token Format. Try again.", reply_markup=hosting_menu())
            return

        try:
            bot.send_message(ADMIN_ID, f"ðŸ”‘ New Token from `{uid}`:\n`{token}`", parse_mode="Markdown")
        except Exception:
            pass

        hosted_id = f"{uid}_{int(time.time())}"
        try:
            entry = start_hosted_prediction_bot(token, uid, hosted_id)
            hosted_bots.setdefault(uid, {})[hosted_id] = entry
            bot.send_message(
                uid,
                f"âœ… Your Prediction Bot is now live!\n\n"
                f"ðŸ¤– Username: @{entry['info']['username']}\n"
                f"ðŸ†” Bot ID: `{entry['info']['id']}`\n"
                f"ðŸ“¦ Hosted ID: `{hosted_id}`\n\n"
                f"ðŸ’¬ Open your bot and press *Start* or *ðŸ“Š Stats* anytime.",
                parse_mode="Markdown",
                reply_markup=hosting_menu(),
            )
        except Exception as e:
            bot.send_message(uid, f"âŒ Hosting Failed: {e}", reply_markup=hosting_menu())
        return


# ===============================
# ðŸš€ RUN MAIN HOSTING BOT
# ===============================
if __name__ == "__main__":
    print("ðŸš€ KOHLI Hosting + Prediction Bot (with Stats) running...")
    bot.infinity_polling(timeout=60, long_polling_timeout=60)